
```{python}
import pandas as pd
import numpy as np 
import yfinance as yf
from plotnine import *
```


GOAL:  Find optimal combination of stocks from different sectors to maximize return and minimize risk of portfolio.

DATA: 5 Different Sectors: Healthcare, Energy, Technology, Consumer Cylical, Financial Services. Went to yahoo finance and found the five largest companies from each sector in terms of market weight. Stocks are listed below in the individual list for each sector as well as in a combined list called tickers.

```{python}
Healthcare_stocks = ['LLY', 'JNJ', 'UNH', 'MRK', 'ABT'] #getting weird value for AABV so switching AABV with ABT
Energy_stocks = ['XOM', 'CVX', 'COP', 'WMB', 'EPD']
Technology_stocks = ['NVDA', 'AAPL', 'MSFT', 'AVGO', 'ORCL']
Consumer_Cylical_stocks = ['AMZN', 'TSLA', 'HD','MCD', 'TJX' ]
Financial_Services_stocks = ['BRK-B', 'JPM', 'V', 'BAC', 'MA']
```


```{python}
ticker_list = ['LLY', 'JNJ', 'UNH', 'MRK', 'ABT',
                'XOM', 'CVX', 'COP', 'WMB', 'EPD',
               'NVDA', 'AAPL', 'MSFT', 'AVGO', 'ORCL',
               'AMZN', 'TSLA', 'HD','MCD', 'TJX' ,
               'BRK-B', 'JPM', 'V', 'BAC', 'MA'

                ]
```

```{python}
tickertest = 'LLY'

start_date = '2000-11-28'
end_date = '2025-11-28'


```

```{python}
try: 
    LLY_Data = yf.download(
        tickers=tickertest,
        start = start_date,
        end = end_date, 
        interval="1d"
    )

    LLY_Data_close = LLY_Data['Close']
except Exception as e:
    print(f"An error occurred: {e}")

new_lly = LLY_Data_close.reset_index()



```


```{python}
stock_df = pd.DataFrame(columns=['Date'])
for t in ticker_list:
    try: 
        ticker_data = yf.download(
            tickers=ticker_list,
            start=start_date,
            end = end_date,
            interval= '1d'
        )
        ticker_data_close = ticker_data['Close']
    except Exception as e:
        print(f"An error occured: {e}")
    ticker_data_close = ticker_data_close.reset_index()
    new = pd.merge(stock_df, ticker_data_close, how = 'right', on = 'Date')
    
```

Need to swap from wide to long so can add sector column 
```{python}
test_melt = pd.melt(new, id_vars='Date', var_name='Ticker')
```

Adding a new column called sector that identifies the sector which each ticker is in and then adding sector names in.
```{python}
test_melt['Sector'] = [None] * len(test_melt)

# Pulling down sector list from above for reference: 
Healthcare_stocks = ['LLY', 'JNJ', 'UNH', 'MRK', 'ABT'] 
Energy_stocks = ['XOM', 'CVX', 'COP', 'WMB', 'EPD']
Technology_stocks = ['NVDA', 'AAPL', 'MSFT', 'AVGO', 'ORCL']
Consumer_Cylical_stocks = ['AMZN', 'TSLA', 'HD','MCD', 'TJX' ]
Financial_Services_stocks = ['BRK-B', 'JPM', 'V', 'BAC', 'MA']

for i in range(0, len(test_melt)):
    current_ticker = test_melt['Ticker'].iloc[i]

    if current_ticker in Healthcare_stocks:
        test_melt.loc[i, "Sector "] = "Health_Care"
    elif current_ticker in Energy_stocks:
        test_melt.loc[i, "Sector"] = "Energy"
    elif current_ticker in Technology_stocks:
        test_melt.loc[i, "Sector"] = "Technology"
    elif current_ticker in Consumer_Cylical_stocks:
        test_melt.loc[i, "Sector"] = "Consumer_Cylical"
    else:
        test_melt.loc[i, "Sector"] = "Financial_Services"

new_melt = test_melt.drop(test_melt.columns[-1], axis = 1)

```


Finding Beta of Each and merging with previous data
```{python}

betas = []

for t in ticker_list:
    betatickers = yf.Ticker(t)
    info = betatickers.info
    beta = info.get('beta')
    betas.append((t, beta))
beta_df = pd.DataFrame(betas, columns=['Ticker', 'beta'])
updated_data= pd.merge(new_melt, beta_df, how = 'inner', on = 'Ticker')

```


Getting Variables for Expected Return

Expected Return = risk free + Beta(expected market return - risk free)

Risk free using t-bill 20 year
Beta pulled from yfinance
expected market return using sp500
```{python}
risk_free_table = pd.read_html("https://home.treasury.gov/resource-center/data-chart-center/interest-rates/TextView?type=daily_treasury_yield_curve&field_tdr_date_value=2025")[0]
last_value = risk_free_table.index[-1]
risk_free = float(risk_free_table.loc[last_value, '20 Yr'])
risk_free
SP500_return_table = pd.read_html("https://www.slickcharts.com/sp500/returns")[0]
SP500_subset = SP500_return_table[SP500_return_table['Year']>=2000]
SP500_subset_mean_return = float(SP500_subset['Total Return'].mean())
```

Expected Return for every stock

```{python}
Expected_Returns = []
for t in beta_df['Ticker']:
    individual_stocks = beta_df[beta_df['Ticker'] == t]
    individual_stocks_beta = individual_stocks['beta']
    individual_stocks_expected_return = float(risk_free + individual_stocks_beta * (SP500_subset_mean_return - risk_free))
    Expected_Returns.append((t, individual_stocks_expected_return))
Expected_Returns_df = pd.DataFrame(Expected_Returns, columns=['Ticker', 'Expected_Return'])
```

Merge the expected returns with existing data

```{python}
Newly_merged = pd.merge(updated_data, Expected_Returns_df, how = 'left', on = 'Ticker')
```

Expected Return of the portfolio if say we owned each of the 25 stocks equally

```{python}
stock_proportion = 1/25
adjusted_temp_return = []

for i in range(0, len(Expected_Returns_df)):
    adjusted_return = Expected_Returns_df['Expected_Return'].iloc[i] * stock_proportion
    adjusted_temp_return.append(adjusted_return)

Total_Return = float(sum(adjusted_temp_return))
```

Need to find variance of every stock. Doing sample variance as not doing every stock on the company and only doing a subset of the stocks we did pull, not the entire stock history was pulled.

variance = sum(Value - mean)^2 / n -1

Need to find correlation values as well. Since we have 25 stocks, there are 300 possible 2 stock combinations. Combination(25,2) = 25!/(2!(25-2)!) = 300

```{python}
Newly_merged.columns = ['Date', 'Ticker', 'Close', 'Sector', 'beta', 'Expected_Return']
Newly_merged['Daily_Return'] = Newly_merged.groupby('Ticker')['Close'].pct_change()

efficient_variance = Newly_merged.groupby('Ticker')['Daily_Return'].var().reset_index()
efficient_variance.columns = ['Ticker', 'Variance']

```



```{python}
test_merge = pd.merge(Newly_merged, efficient_variance, how = 'left', on = 'Ticker')
data = test_merge

```

```{python}
data['Change'] = data.groupby('Ticker')['Close'].diff()
data['SD'] = data['Change'].std()
```

```{python}
five_year_risk_free_std = float(risk_free_table['5 Yr'].std())
five_year_risk_free_return = float(risk_free_table['5 Yr'].mean())
ten_year_risk_free_std = float(risk_free_table['10 Yr'].std())
ten_year_risk_free_return = float(risk_free_table['10 Yr'].mean())
twenty_year_risk_free_std = float(risk_free_table['20 Yr'].std())
twenty_year_risk_free_return = float(risk_free_table['20 Yr'].mean())


risk_free_df = pd.DataFrame({'5 Year Return': five_year_risk_free_return, 
                            '5 Year STD': five_year_risk_free_std,
                            '10 Year Return': ten_year_risk_free_return,
                            '10 Year SD': ten_year_risk_free_std,
                            '20 Year Return': twenty_year_risk_free_return,
                            '20 Year SD': twenty_year_risk_free_std
}, index=['Risk-Free-Asset'])
```


Modern Portfolio Theory

Want to first minimize the risk in expected return so want the optimal set of vars that minimize std 




```{python}
subset2 = data[data['Ticker'] == 'AAPL']
subset3 = data[data['Ticker'] == 'XOM']

plot = (ggplot(subset2,aes(x = 'SD', 
                           y = 'Expected_Return')) + 
                           geom_point()+
                           geom_point(subset3, aes(x = 'SD', y = 'Expected_Return')))
```



